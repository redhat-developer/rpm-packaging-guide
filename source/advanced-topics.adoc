[[advanced-topics]]
= Advanced Topics

This chapter covers topics that are beyond the scope of the introductory
tutorial but are often useful in real-world RPM packaging.

[[Signing-Packages]]
== Signing Packages

Signing a package is a way to secure the package for an end user. Secure transport can be achieved with implementation of the HTTPS protocol, which can be done when the package is downloaded just before installing. However, the packages are often downloaded in advance and stored in local repositories before they are used. The packages are signed to make sure no third party can alter the content of a package.

There are three ways to sign a package:

* xref:Adding-a-Signature-to-a-Package[Adding a signature to an already existing package].

* xref:Replacing-a-Package-Signature[Replacing the signature on an already existing package].

* xref:Build-time-Signing[Signing a package at build-time].

[[Adding-a-Signature-to-a-Package]]
=== Adding a Signature to a Package

In most cases packages are built without a signature. The signature is added just before the release of the package.

In order to add another signature to the package package, use the `--addsign` option.
Having more than one signature makes it possible to record the package's path of ownership
from the package builder to the end-user.

As an example, a division of a company creates a package and signs it with the division's key. The company's headquarters then checks the package's signature and adds the corporate signature to the package, stating that the signed package is authentic.

With two signatures, the package makes its way to a retailer. The retailer checks the signatures and, if they check out, adds their signature as well.

The package now makes its way to a company that wishes to deploy the package. After checking every signature on the package, they know that it is an authentic copy, unchanged since it was first created. Depending on the deploying company's internal controls, they may choose to add their own signature, to reassure their employees that the package has received their corporate approval.


The output from the `--addsign` option:

[source,bash]
----
$ rpm --addsign blather-7.9-1.i386.rpm
            Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
----

To check the signatures of a package with multiple signatures:

[source,bash]
----
$ rpm --checksig blather-7.9-1.i386.rpm
blather-7.9-1.i386.rpm: size pgp pgp md5 OK
----

The two `pgp` strings in the output of the `rpm --checksig` command show that the package has been signed twice.

RPM makes it possible to add the same signature multiple times. The `--addsign` option does not check for multiple identical signatures.

[source,bash]
----
$ rpm --addsig blather-7.9-1.i386.rpm
              Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
$ rpm --addsig blather-7.9-1.i386.rpm
              Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
$ rpm --addsig blather-7.9-1.i386.rpm
              Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
$ rpm --checksig blather-7.9-1.i386.rpm
blather-7.9-1.i386.rpm: size pgp pgp pgp pgp md5 OK
----

The output of the `rpm --checksig` command displays four signatures.

[[Replacing-a-Package-Signature]]
=== Replacing a Package Signature

To change the public key without having to rebuild each package, use the `--resign` option.

[source,bash]
----
$ rpm --resign blather-7.9-1.i386.rpm
            Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
----

To use the --resign option on multiple package files:

[source,bash]
----
$ rpm --resign b*.rpm
            Enter pass phrase:

Pass phrase is good.
blather-7.9-1.i386.rpm:
bother-3.5-1.i386.rpm:
----

[[Build-time-Signing]]
=== Build-time Signing

To sign a package at build-time, use the rpmbuild command with the --sign option. This requires entering the PGP passphrase.

For example:

[source,bash]
----
$ rpmbuild -ba --sign blather-7.9.spec
            Enter pass phrase:

Pass phrase is good.
* Package: blather
…
Binary Packaging: blather-7.9-1
Finding dependencies...
…
Generating signature: 1002
Wrote: /usr/src/redhat/RPMS/i386/blather-7.9-1.i386.rpm
…
Source Packaging: blather-7.9-1
…
Generating signature: 1002
Wrote: /usr/src/redhat/SRPMS/blather-7.9-1.src.rpm
----

The "Generating signature" message appears in both the binary and source packaging sections. The number following the message indicates that the signature added was created using PGP.

[NOTE]
--
When using the `--sign` option for `rpmbuild`, use only -bb or -ba options for package building.
--

To verify the signature of a package, use the rpm command with `--checksig` option. For example:

[source,bash]
----
$ rpm --checksig blather-7.9-1.i386.rpm
blather-7.9-1.i386.rpm: size pgp md5 OK
----

[[Building-Multiple-Packages]]
==== Building Multiple Packages

When building multiple packages, use the following syntax to avoid entering the PGP passphrase multiple times. For example when building the `blather` and `bother` packages, sign them by using the following:

[source,bash]
----
$ rpmbuild -ba --sign b*.spec
              Enter pass phrase:

Pass phrase is good.
* Package: blather
…
Binary Packaging: blather-7.9-1
…
Generating signature: 1002
Wrote: /usr/src/redhat/RPMS/i386/blather-7.9-1.i386.rpm
…
Source Packaging: blather-7.9-1
…
Generating signature: 1002
Wrote: /usr/src/redhat/SRPMS/blather-7.9-1.src.rpm
…
* Package: bother
…
Binary Packaging: bother-3.5-1
…
Generating signature: 1002
Wrote: /usr/src/redhat/RPMS/i386/bother-3.5-1.i386.rpm
…
Source Packaging: bother-3.5-1
…
Generating signature: 1002
Wrote: /usr/src/redhat/SRPMS/bother-3.5-1.src.rpm
----

ifdef::community[]
[[mock]]
== Mock

“ https://github.com/rpm-software-management/mock/wiki[Mock] is a tool for building packages. It can build packages for different
architectures and different Fedora or RHEL versions than the build host has.
Mock creates chroots and builds packages in them. Its only task is to reliably
populate a chroot and attempt to build a package in that chroot.

Mock also offers a multi-package tool, mockchain, that can build chains of
packages that depend on each other.

Mock is capable of building SRPMs from source configuration management if the
mock-scm package is present, then building the SRPM into RPMs. See –scm-enable
in the documentation.” (From the upstream documentation)

NOTE: In order to use https://fedoraproject.org/wiki/Mock[Mock] on a RHEL or CentOS system, you will need to enable
the “Extra Packages for Enterprise Linux” (https://fedoraproject.org/wiki/EPEL[EPEL]) repository. This is
a repository provided by the https://getfedora.org/[Fedora] community and has many useful tools
for RPM Packagers, systems administrators, and developers.

One of the most common use cases RPM Packagers have for https://fedoraproject.org/wiki/Mock[Mock] is to create
what is known as a “pristine build environment”. By using mock as a “pristine
build environment”, nothing about the current state of your system affects
the RPM Package itself. Mock uses different configurations to specify
what the build “target” is, these are found on your system in the ``/etc/mock/``
directory (once you’ve installed the ``mock`` package). You can build for
different distributions or releases just by specifying it on the command line.
Something to keep in mind is that the configuration files that come with mock are
targeted at Fedora RPM Packagers, and as such RHEL and CentOS release versions
are labeled as “epel” because that is the “target” repository these RPMs would
be built for. You simply specify the configuration you want to use (minus the
``.cfg`` file extension). For example, you could build our ``cello`` example
for both RHEL 7 and Fedora 23 using the following commands without ever having
to use different machines.

[source,bash]
----
$ mock -r epel-7-x86_64 ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm

$ mock -r fedora-23-x86_64 ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm

----

One example of why you might want to use mock is if you were packaging RPMs on
your laptop and you had a package installed (we’ll call it ``foo`` for this
example) that was a ``BuildRequires`` of that package you were creating but
forgot to actually make the ``BuildRequires: foo`` entry. The build would
succeed when you run ``rpmbuild`` because ``foo`` was needed to build and it was
found on the system at build time. However, if you took the SRPM to another
system that lacked ``foo`` it would fail, causing an unexpected side effect.
https://fedoraproject.org/wiki/Mock[Mock] solves this by first parsing the contents of the SRPM and installing the
``BuildRequires`` into its https://en.wikipedia.org/wiki/Chroot[chroot] which means that if you were missing the
``BuildRequires`` entry, the build would fail because mock would not know to
install it and it would therefore not be present in the buildroot.

Another example is the opposite scenario, let’s say you need ``gcc`` to build
a package but don’t have it installed on your system (which is unlikely as an RPM
Packager, but just for the sake of the example let us pretend that is true).
With https://fedoraproject.org/wiki/Mock[Mock], you don’t have to install ``gcc`` on your system because it will
get installed in the chroot as part of mock’s process.

Below is an example of attempting to rebuild a package that has a dependency
that I’m missing on my system. The key thing to note is that while ``gcc`` is
commonly on most RPM Packager’s systems, some RPM Packages can have over a dozen
``BuildRequires`` and this allows you to not need to clutter up your workstation
with otherwise un-needed or un-necessary packages.

[source,bash]
----
$ rpmbuild --rebuild ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
Installing /home/admiller/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
error: Failed build dependencies: gcc is needed by cello-1.0-1.el7.x86_64

$ mock -r epel-7-x86_64 ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
INFO: mock.py version 1.2.17 starting (python version = 2.7.5)...
Start: init plugins
INFO: selinux enabled
Finish: init plugins
Start: run
INFO: Start(/home/admiller/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm)  Config(epel-7-x86_64)
Start: clean chroot
Finish: clean chroot
Start: chroot init
INFO: calling preinit hooks
INFO: enabled root cache
Start: unpacking root cache
Finish: unpacking root cache
INFO: enabled yum cache
Start: cleaning yum metadata
Finish: cleaning yum metadata
Mock Version: 1.2.17
INFO: Mock Version: 1.2.17
Start: yum update
base                                                                    | 3.6 kB  00:00:00
epel                                                                    | 4.3 kB  00:00:00
extras                                                                  | 3.4 kB  00:00:00
updates                                                                 | 3.4 kB  00:00:00
No packages marked for update
Finish: yum update
Finish: chroot init
Start: build phase for cello-1.0-1.el7.src.rpm
Start: build setup for cello-1.0-1.el7.src.rpm
warning: Could not canonicalize hostname: rhel7
Building target platforms: x86_64
Building for target x86_64
Wrote: /builddir/build/SRPMS/cello-1.0-1.el7.centos.src.rpm
Getting requirements for cello-1.0-1.el7.centos.src
 --> Already installed : gcc-4.8.5-4.el7.x86_64
 --> Already installed : 1:make-3.82-21.el7.x86_64
No uninstalled build requires
Finish: build setup for cello-1.0-1.el7.src.rpm
Start: rpmbuild cello-1.0-1.el7.src.rpm
Building target platforms: x86_64
Building for target x86_64
Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.v9rPOF
+ umask 022
+ cd /builddir/build/BUILD
+ cd /builddir/build/BUILD
+ rm -rf cello-1.0
+ /usr/bin/gzip -dc /builddir/build/SOURCES/cello-1.0.tar.gz
+ /usr/bin/tar -xf -
+ STATUS=0
+ '[' 0 -ne 0 ']'
+ cd cello-1.0
+ /usr/bin/chmod -Rf a+rX,u+w,g-w,o-w .
Patch #0 (cello-output-first-patch.patch):
+ echo 'Patch #0 (cello-output-first-patch.patch):'
+ /usr/bin/cat /builddir/build/SOURCES/cello-output-first-patch.patch
patching file cello.c
+ /usr/bin/patch -p0 --fuzz=0
+ exit 0
Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.UxRVtI
+ umask 022
+ cd /builddir/build/BUILD
+ cd cello-1.0
+ make -j2
gcc -g -o cello cello.c
+ exit 0
Executing(%install): /bin/sh -e /var/tmp/rpm-tmp.K3i2dL
+ umask 022
+ cd /builddir/build/BUILD
+ '[' /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64 '!=' / ']'
+ rm -rf /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
++ dirname /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
+ mkdir -p /builddir/build/BUILDROOT
+ mkdir /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
+ cd cello-1.0
+ /usr/bin/make install DESTDIR=/builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
mkdir -p /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/bin
install -m 0755 cello /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/bin/cello
+ /usr/lib/rpm/find-debuginfo.sh --strict-build-id -m --run-dwz --dwz-low-mem-die-limit 10000000 --dwz-max-die-limit 110000000 /builddir/build/BUILD/cello-1.0
extracting debug info from /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/bin/cello
dwz: Too few files for multifile optimization
/usr/lib/rpm/sepdebugcrcfix: Updated 0 CRC32s, 1 CRC32s did match.
+ /usr/lib/rpm/check-buildroot
+ /usr/lib/rpm/redhat/brp-compress
+ /usr/lib/rpm/redhat/brp-strip-static-archive /usr/bin/strip
+ /usr/lib/rpm/brp-python-bytecompile /usr/bin/python 1
+ /usr/lib/rpm/redhat/brp-python-hardlink
+ /usr/lib/rpm/redhat/brp-java-repack-jars
Processing files: cello-1.0-1.el7.centos.x86_64
Executing(%license): /bin/sh -e /var/tmp/rpm-tmp.vxtAuO
+ umask 022
+ cd /builddir/build/BUILD
+ cd cello-1.0
+ LICENSEDIR=/builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/share/licenses/cello-1.0
+ export LICENSEDIR
+ /usr/bin/mkdir -p /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/share/licenses/cello-1.0
+ cp -pr LICENSE /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64/usr/share/licenses/cello-1.0
+ exit 0
Provides: cello = 1.0-1.el7.centos cello(x86-64) = 1.0-1.el7.centos
Requires(rpmlib): rpmlib(CompressedFileNames) <= 3.0.4-1 rpmlib(FileDigests) <= 4.6.0-1 rpmlib(PayloadFilesHavePrefix) <= 4.0-1
Requires: libc.so.6()(64bit) libc.so.6(GLIBC_2.2.5)(64bit) rtld(GNU_HASH)
Processing files: cello-debuginfo-1.0-1.el7.centos.x86_64
Provides: cello-debuginfo = 1.0-1.el7.centos cello-debuginfo(x86-64) = 1.0-1.el7.centos
Requires(rpmlib): rpmlib(FileDigests) <= 4.6.0-1 rpmlib(PayloadFilesHavePrefix) <= 4.0-1 rpmlib(CompressedFileNames) <= 3.0.4-1
Checking for unpackaged file(s): /usr/lib/rpm/check-files /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
Wrote: /builddir/build/RPMS/cello-1.0-1.el7.centos.x86_64.rpm
warning: Could not canonicalize hostname: rhel7
Wrote: /builddir/build/RPMS/cello-debuginfo-1.0-1.el7.centos.x86_64.rpm
Executing(%clean): /bin/sh -e /var/tmp/rpm-tmp.JuPOtY
+ umask 022
+ cd /builddir/build/BUILD
+ cd cello-1.0
+ /usr/bin/rm -rf /builddir/build/BUILDROOT/cello-1.0-1.el7.centos.x86_64
+ exit 0
Finish: rpmbuild cello-1.0-1.el7.src.rpm
Finish: build phase for cello-1.0-1.el7.src.rpm
INFO: Done(/home/admiller/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm) Config(epel-7-x86_64) 0 minutes 16 seconds
INFO: Results and/or logs in: /var/lib/mock/epel-7-x86_64/result
Finish: run

----

As you can see, mock is a fairly verbose tool. You will also notice a lot of
http://yum.baseurl.org/[yum] or https://github.com/rpm-software-management/dnf[dnf] output (depending on RHEL7, CentOS7, or Fedora mock target)
that is not found in this output which was omitted for brevity and is often
omitted after you have done an ``--init`` on a mock target, such as
``mock -r epel-7-x86_64 --init`` which will pre-download all the
required packages, cache them, and pre-stage the build chroot.

For more information, please consult the https://github.com/rpm-software-management/mock/wiki[Mock] upstream documentation.
endif::community[]

ifdef::community[]
[[version-control-systems]]
== Version Control Systems

When working with RPMs, it is often desireable to utilize a https://en.wikipedia.org/wiki/Version_control[Version Control
System] (VCS) such as https://git-scm.com/[git] for managing components of the software we are
packaging. Something to note is that storing binary files in a VCS is not
favorable because it will drastically inflate the size of the source repository
as these tools are engineered to handle differentials in files (often optimized
for text files) and this is not something that binary files lend themselves to
so normally each whole binary file is stored. As a side effect of this there are
some clever utilities that are popular among upstream Open Source projects that
work around this problem by either storing the SPEC file where the source code
is in a VCS (i.e. - it is not in a compressed archive for redistribution) or
place only the SPEC file and patches in the VCS and upload the compressed
archive of the upstream release source to what is called a “look aside cache”.

In this section we will cover two different options for using a VCS system,
https://git-scm.com/[git], for managing the contents that will ultimately be turned into a RPM
package. One is called https://github.com/dgoodwin/tito[tito] and the other is https://github.com/release-engineering/dist-git[dist-git].

NOTE: For the duration of this section you will need to install the ``git``
package on you system in order to follow along.

[[tito]]
=== tito

Tito is an utility that assumes all the source code for the software that is
going to be packaged is already in a https://git-scm.com/[git] source control repository. This is
good for those practicing a DevOps workflow as it allows for the team writing
the software to maintain their normal https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows[Branching Workflow]. Tito will then
allow for the software to be incrementally packaged, built in an automated
fashion, and still provide a native installation experience for http://rpm.org/[RPM] based
systems.

NOTE: The https://github.com/dgoodwin/tito[tito] package is available in https://getfedora.org/[Fedora] as well as in the https://fedoraproject.org/wiki/EPEL[EPEL]
repository for use on RHEL 7 and CentOS 7.

Tito operates based on https://git-scm.com/book/en/v2/Git-Basics-Tagging[git tags] and will manage tags for you if you elect to
allow it, but can optionally operate under whatever tagging scheme you prefer as
this functionality is configurable.

Let’s explore a little bit about tito by looking at an upstream project already
using it. We will actually be using the upstream git repository of the project
that is our next section’s subject, https://github.com/release-engineering/dist-git[dist-git]. Since this project is publicly
hosted on is publicly hosted on https://github.com/[GitHub], let’s go ahead and clone the git
repo.

[source,bash]
----
$ git clone https://github.com/release-engineering/dist-git.git
Cloning into 'dist-git'...
remote: Counting objects: 425, done.
remote: Total 425 (delta 0), reused 0 (delta 0), pack-reused 425
Receiving objects: 100% (425/425), 268.76 KiB | 0 bytes/s, done.
Resolving deltas: 100% (184/184), done.
Checking connectivity... done.

$ cd dist-git/

$ ls *.spec
dist-git.spec

$ tree rel-eng/
rel-eng/
├── packages
│   └── dist-git
└── tito.props

1 directory, 2 files

----

As we can see here, the spec file is at the root of the git repository and there
is a ``rel-eng`` directory in the repository which is used by tito for general
book keeping, configuration, and various advanced topics like custom tito
modules. We can see in the directory layout that there is a sub-directory
entitled ``packages`` which will store a file per package that tito manages in
the repository as you can have many RPMs in a single git repository and tito
will handle that just fine. In this scenario however, we see only a single
package listing and it should be noted that it matches the name of our spec
file. All of this is setup by the command ``tito init`` when the developers of
https://github.com/release-engineering/dist-git[dist-git] first initialized their git repo to be managed by tito.

If we were to follow a common workflow of a DevOps Practitioner then we would
likely want to use this as part of a https://en.wikipedia.org/wiki/Continuous_integration[Continuous Integration] (CI) or
https://en.wikipedia.org/wiki/Continuous_delivery[Continuous Delivery] (CD) process. What we can do in that scenario is perform
what is known as a “test build” to tito, we can even use mock to do this. We
could then use the output as the installation point for some other component in
the pipeline. Below is a simple example of commands that could accomplish this
and they could be adapted to other environments.

[source,bash]
----
$ tito build --test --srpm
Building package [dist-git-0.13-1]
Wrote: /tmp/tito/dist-git-git-0.efa5ab8.tar.gz

Wrote: /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.fc23.src.rpm

$ tito build --builder=mock --arg mock=epel-7-x86_64 --test --rpm
Building package [dist-git-0.13-1]
Creating rpms for dist-git-git-0.efa5ab8 in mock: epel-7-x86_64
Wrote: /tmp/tito/dist-git-git-0.efa5ab8.tar.gz

Wrote: /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.fc23.src.rpm

Using srpm: /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.fc23.src.rpm
Initializing mock...
Installing deps in mock...
Building RPMs in mock...
Wrote:
  /tmp/tito/dist-git-selinux-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm
  /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm

$ sudo yum localinstall /tmp/tito/dist-git-*.noarch.rpm
Loaded plugins: product-id, search-disabled-repos, subscription-manager
Examining /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm: dist-git-0.13-1.git.0.efa5ab8.el7.centos.noarch
Marking /tmp/tito/dist-git-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm to be installed
Examining /tmp/tito/dist-git-selinux-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm: dist-git-selinux-0.13-1.git.0.efa5ab8.el7.centos.noarch
Marking /tmp/tito/dist-git-selinux-0.13-1.git.0.efa5ab8.el7.centos.noarch.rpm to be installed
Resolving Dependencies
--> Running transaction check
---> Package dist-git.noarch 0:0.13-1.git.0.efa5ab8.el7.centos will be installed

----

Note that the final command would need to be run with either sudo or root
permissions and that much of the output has been omitted for brevity as the
dependency list is quite long.

This concludes our simple example of how to use tito but it has many amazing
features for traditional Systems Administrators, RPM Packagers, and DevOps
Practitioners alike. I would highly recommend consulting the upstream
documentation found at the _tito_ GitHub site for more information on how to
quickly get started using it for your project as well as various advanced
features it offers.

[[dist-git]]
=== dist-git

The https://github.com/release-engineering/dist-git[dist-git] utility takes a slightly different approach from that of https://github.com/dgoodwin/tito[tito]
such that instead of keeping the raw source code in https://git-scm.com/[git] it instead will keep
spec files and patches in a git repository and upload the compressed archive of
the source code to what is known as a “look-aside cache”. The “look-aside-cache”
is a term that was coined by the use of RPM Build Systems storing large files
like these “on the side”. A system like this is generally tied to a proper RPM
Build System such as https://fedorahosted.org/koji/[Koji]. The build system is then configured to pull the
items that are listed as ``SourceX`` entries in the spec files in from this
look-aside-cache, while the spec and patches remain in a version control system.
There is also a helper command line tool to assist in this.

In an effort to not duplicate documentation, for more information on how to
setup a system such as this please refer to the upstream https://github.com/release-engineering/dist-git[dist-git] docs.
upstream docs.
endif::community[]

[[more-on-macros]]
== More on Macros

There are many built-in RPM Macros and we will cover a few in the following
section, however an exhaustive list can be found at the rpm.org http://rpm.org/user_doc/macros.html[rpm macro] official documentation.

ifdef::community[]
There are also macros that are provided by your https://en.wikipedia.org/wiki/Linux[Linux] Distribution, we will
cover some of those provided by https://getfedora.org/[Fedora], https://www.centos.org/[CentOS] and https://www.redhat.com/en/technologies/linux-platforms[RHEL] in this section
as well as provide information on how to inspect your system to learn about
others that we don’t cover or for discovering them on other RPM-based Linux
Distributions.
endif::community[]

ifdef::rhel[]
There are also macros that are provided by Red Hat Enterprise Linux, some of which we cover in this section. We also see how to inspect your system to learn about other macros.
endif::rhel[]

[[defining-your-own]]
=== Defining Your Own Macros

You can define your own Macros. Below is an excerpt from the
http://rpm.org/user_doc/macros.html[RPM Official Documentation], which provides a
comprehensive reference on macros capabilities.

To define a macro, use:

[source,specfile]
----
%global <name>[(opts)] <body>
----

All whitespace surrounding `\` is removed.  Name may be composed
of alphanumeric characters, and the character `_` and must be at least
3 characters in length. A macro without an `(opts)` field is “simple” in that
only recursive macro expansion is performed. A parameterized macro contains
an `(opts)` field. The `opts` (the string between parentheses) is passed
exactly as is to getopt(3) for argc/argv processing at the beginning of
a macro invocation.

[NOTE]
--
Older RPM SPEC files may use the `%define <name> <body>` macro pattern. The differences between `%define` and `%global` macros are as follows:

* `%define` has local scope, which means that it applies only to a specified part of a SPEC file. In addition, the body of a `%define` macro is expanded when used--it is lazily evaluated.
* `%global` has global scope, which means that it applies to an entire SPEC file. In addition, the body of a `%global` macro is expanded at definition time.
--

Examples:

----
%global githash 0ec4e58
%global python_sitelib %(%{__python} -c "from distutils.sysconfig import get_python_lib; print(get_python_lib())")
----

NOTE: Macros are always evaluated, even in comments. Sometimes it is harmless. But in the second example, we are executing python command to get the content of a macro. This command will be executed even when you comment out the macro. Or when you put the name of the macro into %changelog. To comment out macro, use `%%`. For example: `%%global`.

[[setup]]
=== %setup

Macro ``%setup`` can be used to build the package with source code tarballs. Standard behavior of the ``%setup`` macro can be seen in the ``rpmbuild`` output. At the beginning of each phase macro outputs ``Executing(%something)``. For example:

[source,bash]
----
Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.DhddsG
----

The shell output is set with ``set -x`` enabled. To see the content of ``/var/tmp/rpm-tmp.DhddsG`` use ``--debug`` option, since ``rpmbuild`` deletes temporary files after successful build. This displays the setup of environment variables followed by for example:

[source,bash]
----
cd '/builddir/build/BUILD'
rm -rf 'cello-1.0'
/usr/bin/gzip -dc '/builddir/build/SOURCES/cello-1.0.tar.gz' | /usr/bin/tar -xof -
STATUS=$?
if [ $STATUS -ne 0 ]; then
  exit $STATUS
fi
cd 'cello-1.0'
/usr/bin/chmod -Rf a+rX,u+w,g-w,o-w .
----

The ``%setup`` ensures that we are working in the right directory, removes residues of previous builds, unpacks the source tarball, and sets up some default privileges. There are multiple options to adjust the behavior of the ``%setup`` macro.

[[setup-q]]
==== %setup -q

Option ``-q`` limits verbosity of ``%setup`` macro. Only ``tar -xof`` is executed instead of ``tar -xvvof``. This option has to be used as first.

[[setup-n]]
==== %setup -n

In some cases, the directory from expanded tarball has a different name than expected ``%{name}-%{version}``. This can lead to an error of the ``%setup`` macro.  The name of a directory has to be specified by ``-n directory_name`` option.

For example, if the package name is ``cello``, but the source code is archived in ``hello-1.0.tgz`` and contained ``hello/`` directory, the spec file content needs to be:

[source,specfile]
----
Name: cello
Source0: https://example.com/%{name}/release/hello-%{version}.tar.gz
…
%prep
%setup -n hello
----

[[setup-c]]
==== %setup -c


The ``-c`` option can be used if the source code tarball does not contain any subdirectories and after unpacking, files from an archive fill the current directory. The ``-c`` option creates the directory and steps into the archive expansion. An illustrative example:

[source,bash]
----
/usr/bin/mkdir -p cello-1.0
cd 'cello-1.0'
----

The directory is not changed after archive expansion.

[[setup-dt]]
==== %setup -D and -T

``-D`` option disables deleting of source code directory. This option is useful if ``%setup`` macro is used several times. Essentially, ``-D`` option means that following lines are not used:

[source,bash]
----
rm -rf 'cello-1.0'
----

The ``-T`` option disables expansion of the source code tarball by removing the following line from the script:

[source,bash]
----
/usr/bin/gzip -dc '/builddir/build/SOURCES/cello-1.0.tar.gz' | /usr/bin/tar -xvvof -
----

[[setup-ab]]
==== %setup -a and -b

Options ``-a`` and ``-b`` expand specific sources.

* Option ``-b`` (which stands for `before`) expands specific sources before entering the working directory.
* Option ``-a`` (which stands for `after`) expands those sources after entering. Their arguments are source numbers from the spec file preamble.

For example, let's say the ``cello-1.0.tar.gz`` archive contains empty ``examples`` directory, and the examples are shipped in separate ``examples.tar.gz`` tarball and they expand into the directory of the same name. In this case use ``-a 1``, as we want to expand ``Source1`` after entering the working directory:

[source,specfile]
----
Source0: https://example.com/%{name}/release/%{name}-%{version}.tar.gz
Source0: examples.tar.gz
…
%prep
%setup -a 1
----

But if the examples were in the separate ``cello-1.0-examples.tar.gz`` tarball, which expands into ``cello-1.0/examples``, use ``-b 1`` options, since the ``Source1`` should be expanded before entering the working directory:

[source,specfile]
----
Source0: https://example.com/%{name}/release/%{name}-%{version}.tar.gz
Source0: %{name}-%{version}-examples.tar.gz
…
%prep
%setup -b 1
----

You can also use a combination of all these options.

[[files]]
=== %files

Common “advanced” RPM Macros needed in the ``%files`` section are as follows:

[cols="20%,80%"]
|====
| Macro | Definition
| %license | This identifies the file listed as a LICENSE file and it
will be installed and labeled as such by RPM.
Example: ``%license LICENSE``
| %doc | This identifies the file listed as documentation and it
will be installed and labeled as such by RPM. This is often
used not only for documentation about the software being
packaged but also code examples and various items that
should accompany documentation. In the event code examples
are included, care should be taken to remove executable
mode from the file.
Example: ``%doc README``
| %dir | Identifies that the path is a directory that should be owned
by this RPM. This is important so that the rpm file manifest
accurately knows what directories to clean up on uninstall.
Example: ``%dir %{_libdir}/%{name}``
| %config(noreplace) | Specifies that the following file is a configuration file
and therefore should not be overwritten (or replaced) on
a package install or update if the file has been modified
from the original installation checksum. In the event that
there is a change, the file will be created with ``.rpmnew``
appended to the end of the filename upon upgrade or install
so that the pre-existing or modified file on the target
system is not modified.
Example: ``%config(noreplace)
%{_sysconfdir}/%{name}/%{name}.conf``
|====

[[built-in-macros]]
=== Built-In Macros

Your system has many built-in RPM Macros and the fastest way to view them all is
to simply run the ``rpm --showrc`` command. Note that this will contain
a lot of output so it is often used in combination with a pipe to grep.

You can also find information about the RPMs macros that come directly with your
system’s version of RPM by looking at the output of the  ``rpm -ql rpm``
taking note of the files titled ``macros`` in the directory structure.

[[rpm-distribution-macros]]
=== RPM Distribution Macros

Different distributions will supply different sets of recommended RPM Macros
based on the language implementation of the software being packaged or the
specific Guidelines of the distribution in question.

ifdef::community[]
These are often provided as RPM Packages themselves and can be installed with
the distribution package manager, such as http://yum.baseurl.org/[yum] or https://github.com/rpm-software-management/dnf[dnf]. The macro files
themselves once installed can be found in ``/usr/lib/rpm/macros.d/`` and will be
included in the ``rpm --showrc`` output by default once installed.
endif::community[]

ifdef::rhel[]
These are often provided as RPM Packages themselves and can be installed with
the distribution package manager, such as http://yum.baseurl.org/[yum]. The macro files
themselves once installed can be found in ``/usr/lib/rpm/macros.d/`` and will be
included in the ``rpm --showrc`` output by default once installed.
endif::rhel[]

One primary example of this is the https://fedoraproject.org/wiki/Packaging:Guidelines?rd=Packaging/Guidelines[Fedora Packaging Guidelines] section
pertaining specifically to https://fedoraproject.org/wiki/Packaging:Guidelines#Application_Specific_Guidelines[Application Specific Guidelines] which at the time
of this writing has over 60 different sets of guidelines along with associated
RPM Macro sets for subject matter specific RPM Packaging.

ifdef::community[]
One example of this kind of RPMs would be for https://www.python.org/[Python] version 2.x and if we
have the ``python2-rpm-macros`` package installed (available in EPEL for RHEL
7 and CentOS 7), we have a number of python2 specific macros available to us.
endif::community[]

ifdef::rhel[]
One example of this kind of RPMs would be for https://www.python.org/[Python] version 2.x and if we
have the ``python2-rpm-macros`` package installed (available in EPEL for RHEL
7), we have a number of python2 specific macros available to us.
endif::rhel[]


[source,bash]
----
$ rpm -ql python2-rpm-macros
/usr/lib/rpm/macros.d/macros.python2

$ rpm --showrc | grep python2
-14: __python2  /usr/bin/python2
CFLAGS="%{optflags}" %{__python2} %{py_setup} %{?py_setup_args} build --executable="%{__python2} %{py2_shbang_opts}" %{?1}
CFLAGS="%{optflags}" %{__python2} %{py_setup} %{?py_setup_args} install -O1 --skip-build --root %{buildroot} %{?1}
-14: python2_sitearch   %(%{__python2} -c "from distutils.sysconfig import get_python_lib; print(get_python_lib(1))")
-14: python2_sitelib    %(%{__python2} -c "from distutils.sysconfig import get_python_lib; print(get_python_lib())")
-14: python2_version    %(%{__python2} -c "import sys; sys.stdout.write('{0.major}.{0.minor}'.format(sys.version_info))")
-14: python2_version_nodots     %(%{__python2} -c "import sys; sys.stdout.write('{0.major}{0.minor}'.format(sys.version_info))")

----

The above output displays the raw RPM Macro definitions, but we are likely more
interested in what these will evaluate to which we can do with ``rpm --eval`` in
order to determine what they do as well as how they may be helpful to us when
packaging RPMs.

[source,bash]
----
$ rpm --eval %{__python2}
/usr/bin/python2

$ rpm --eval %{python2_sitearch}
/usr/lib64/python2.7/site-packages

$ rpm --eval %{python2_sitelib}
/usr/lib/python2.7/site-packages

$ rpm --eval %{python2_version}
2.7

$ rpm --eval %{python2_version_nodots}
27

----



[[custom-macros]]
== Custom Macros

You can override the distribution macros in the ``~/.rpmmacros`` file. Any changes you make  will affect every build on your machine.

There are several macros you can use to override:

``%_topdir /opt/some/working/directory/rpmbuild``:: You can create this directory, including all subdirectories using the ``rpmdev-setuptree`` utility. The value of this macro is by default ``~/rpmbuild``. 

``%_smp_mflags -l3``:: This macro is often used to pass to Makefile, for example ``make %{?_smp_mflags}``, and to set a number of concurrent processes during the build phase. By default, it is set to ``-jX``, where ``X`` is a number of cores. If you alter the number of cores, you can speed up or slow down a build of packages.

While you can define any new macros in the ``~/.rpmmacros`` file, this is discouraged, because those macros would not be present on other machines, where users may want to try to rebuild your package.



[[epoch-scriptlets-and-triggers]]
== Epoch, Scriptlets, and Triggers

There are various topics in the world of RPM spec files that are considered
advanced because they have implications on not only the spec file, how the
package is built, but also on the end machine that the resulting RPM is
installed upon. In this section we will cover the most common of these such as
Epoch, Scriptlets, and Triggers.

[[epoch]]
=== Epoch

First on the list is ``Epoch``, epoch is a way to define weighted dependencies
based on version numbers. It’s default value is 0 and this is assumed if an
``Epoch`` directive is not listed in the RPM spec file. This was not covered in
the spec File section of this guide because it is almost always a bad idea to
introduce an Epoch value as it will skew what you would normally otherwise
expect RPM to do when comparing versions of packages.

For example if a package ``foobar`` with ``Epoch: 1`` and ``Version: 1.0`` was
installed and someone else packaged ``foobar`` with ``Version: 2.0`` but simply
omitted the ``Epoch`` directive either because they were unaware of it’s
necessity or simply forgot, that new version would never be considered an update
because the Epoch version would win out over the traditional
Name-Version-Release marker that signifies versioning for RPM Packages.

This approach is generally only used when absolutely necessary (as a last
resort) to resolve an upgrade ordering issue which can come up as a side effect
of upstream software changing versioning number schemes or versions
incorporating alphabetical characters that can not always be compared reliably
based on encoding.

[[triggers-and-scriptlets]]
=== Triggers and Scriptlets

In RPM Packages, there are a series of directives that can be used to inflict
necessary or desired change on a system during install time of the RPM. These
are called **scriptlets**.

One primary example of when and why you’d want to do this is when a system
service RPM is installed and it provides a https://freedesktop.org/wiki/Software/systemd/[systemd] https://www.freedesktop.org/software/systemd/man/systemd.unit.html[unit file]. At install
time we will need to notify https://freedesktop.org/wiki/Software/systemd/[systemd] that there is a new unit so that the
system administrator can run a command similar to ``systemctl start
foo.service`` after the fictional RPM ``foo`` (which provides some service
daemon in this example) has been installed. Similarly, we would need to inverse
of this action upon uninstallation so that an administrator would not get errors
due to the daemon’s binary no longer being installed but the unit file still
existing in systemd’s running configuration.

There are a small handful of common scriptlet directives, they are similar to
the “section headers” like ``%build`` or ``%install`` in that they are defined
by multi-line segments of code, often written as standard
ifdef::community[https://en.wikipedia.org/wiki/POSIX[POSIX]]
ifdef::rhel[POSIX]
shell script
but can be a few different programming languages such that RPM for the target
machine’s distribution is configured to allow them. An exhaustive list of these
available languages can be found in the _RPM Official Documentation_.

Scriptlet directives are as follows:

[cols="20%,80%"]
|====
| Directive | Definition
| ``%pre`` | Scriptlet that is executed just before the package is
installed on the target system.
| ``%post`` | Scriptlet that is executed just after the package is
installed on the target system.
| ``%preun`` | Scriptlet that is executed just before the package is
uninstalled from the target system.
| ``%postun`` | Scriptlet that is executed just after the package is
uninstalled from the target system.
|====

Is is also common for RPM Macros to exist for this function. In our previous
example we discussed https://freedesktop.org/wiki/Software/systemd/[systemd] needing to be notified about a new https://www.freedesktop.org/software/systemd/man/systemd.unit.html[unit file],
this is easily handled by the systemd scriptlet macros as we can see from the
below example output. More information on this can be found in the https://fedoraproject.org/wiki/Packaging:Systemd[Fedora
systemd Packaging Guidelines].

[source,bash]
----
$ rpm --showrc | grep systemd
-14: __transaction_systemd_inhibit      %{__plugindir}/systemd_inhibit.so
-14: _journalcatalogdir /usr/lib/systemd/catalog
-14: _presetdir /usr/lib/systemd/system-preset
-14: _unitdir   /usr/lib/systemd/system
-14: _userunitdir       /usr/lib/systemd/user
/usr/lib/systemd/systemd-binfmt %{?*} >/dev/null 2>&1 || :
/usr/lib/systemd/systemd-sysctl %{?*} >/dev/null 2>&1 || :
-14: systemd_post
-14: systemd_postun
-14: systemd_postun_with_restart
-14: systemd_preun
-14: systemd_requires
Requires(post): systemd
Requires(preun): systemd
Requires(postun): systemd
-14: systemd_user_post  %systemd_post --user --global %{?*}
-14: systemd_user_postun        %{nil}
-14: systemd_user_postun_with_restart   %{nil}
-14: systemd_user_preun
systemd-sysusers %{?*} >/dev/null 2>&1 || :
echo %{?*} | systemd-sysusers - >/dev/null 2>&1 || :
systemd-tmpfiles --create %{?*} >/dev/null 2>&1 || :

$ rpm --eval %{systemd_post}

if [ $1 -eq 1 ] ; then
        # Initial installation
        systemctl preset  >/dev/null 2>&1 || :
fi

$ rpm --eval %{systemd_postun}

systemctl daemon-reload >/dev/null 2>&1 || :

$ rpm --eval %{systemd_preun}

if [ $1 -eq 0 ] ; then
        # Package removal, not upgrade
        systemctl --no-reload disable  > /dev/null 2>&1 || :
        systemctl stop  > /dev/null 2>&1 || :
fi

----

Another item that provides even more fine grained control over the RPM
Transaction as a whole is what is known as **triggers**. These are effectively
the same thing as a scriptlet but are executed in a very specific order of
operations during the RPM install or upgrade transaction allowing for a more
fine grained control over the entire process.

The order in which each is executed and the details of which are provided below.

[source,specfile]
----
all-%pretrans
...
any-%triggerprein (%triggerprein from other packages set off by new install)
new-%triggerprein
new-%pre      for new version of package being installed
...           (all new files are installed)
new-%post     for new version of package being installed

any-%triggerin (%triggerin from other packages set off by new install)
new-%triggerin
old-%triggerun
any-%triggerun (%triggerun from other packages set off by old uninstall)

old-%preun    for old version of package being removed
...           (all old files are removed)
old-%postun   for old version of package being removed

old-%triggerpostun
any-%triggerpostun (%triggerpostun from other packages set off by old un
            install)
...
all-%posttrans

----

ifdef::community[]
The above items are from the included RPM documentation found in
``/usr/share/doc/rpm/triggers`` on Fedora systems and
``/usr/share/doc/rpm-4.*/triggers`` on RHEL 7 and CentOS 7 systems.
endif::community[]

ifdef::rhel[]
The above items are from the included RPM documentation found in
``/usr/share/doc/rpm-4.*/triggers``.
endif::rhel[]

[id="Using-Non-Shell-Scripts-in-spec-File"]
==== Using Non-Shell Scripts in spec File

A scriptlet option, `-p`, in a spec file allows to invoke a specific interpreter instead of the default `-p{nbsp}/bin/sh`. An illustrative example is a script, which prints out a message after the installation of `pello.py`.

. Open the `pello.spec` file. 

. Find the following line:
+
[source,specfile]
----
install -m 0644 %{name}.py* %{buildroot}/usr/lib/%{name}/
----
+
Under this line, insert the following code:
+
[source,specfile]
----
%post -p /usr/bin/python3
print("This is {} code".format("python"))
----

. Build your package according to the xref:building-rpms[] chapter.

ifdef::community[]
. Install your package:
+
[source,bash]
----
# dnf install /home/<username>/rpmbuild/RPMS/noarch/pello-0.1.1-1.fc27.noarch.rpm
----
+
The output of this command is the following message after the installation:
+
[source]
----
Installing       : pello-0.1.1-1.fc27.noarch                              1/1
Running scriptlet: pello-0.1.1-1.fc27.noarch                              1/1
This is python code
----
endif::community[]

ifdef::rhel[]
. Install your package:
+
[source,bash]
----
# yum install /home/<username>/rpmbuild/RPMS/noarch/pello-0.1.1-1.fc27.noarch.rpm
----
+
The output of this command is the following message after the installation:
+
[source]
----
Installing       : pello-0.1.1-1.fc27.noarch                              1/1
Running scriptlet: pello-0.1.1-1.fc27.noarch                              1/1
This is python code
----
endif::rhel[]

[NOTE]
--
* To use a Python{nbsp}3 script:
Write a line `%post -p /usr/bin/python3` under the line `install -m` in a spec file.

* To use a Lua script:
Write a line `%post -p <lua>` under the line `install{nbsp}-m` in a spec file.

* This way any interpreter can be specified in the spec file.
--

[[rpm-conditionals]]
== RPM Conditionals

RPM Conditionals enable the conditional inclusion of various sections of the spec file.

Most commonly, conditional inclusions deal with:

* architecture-specific sections
* operating system-specific sections
* compatibility issues between various versions of operating systems
* existence and definition of macros

=== RPM Conditionals Syntax

If _expression_ is true, then do some action:

  %if expression
  ...
  %endif

If _expression_ is true, then do some action, in other case, do another action:

  %if expression
  ...
  %else
  ...
  %endif

// If _expression_ is not true, then do some action.

//  %if !expression
//   ...
//   %endif

// If _expression_ is not true, then do some action, in other case, do another action.

//  %if !expression
//  ...
//  %else
//  ...
//  %endif

=== RPM Conditionals Examples

==== The `%if` Conditional

  %if 0%{?rhel} == 6
  sed -i '/AS_FUNCTION_DESCRIBE/ s/^/#/' configure.in
  sed -i '/AS_FUNCTION_DESCRIBE/ s/^/#/' acinclude.m4
  %endif

This conditional handles compatibility between RHEL6 and other operating systems in terms of support of the AS_FUNCTION_DESCRIBE macro. When the package is build for RHEL, the `%rhel` macro is defined and it is expanded to RHEL version. If its value is 6, meaning the package is build for RHEL 6, then the references to AS_FUNCTION_DESCRIBE, which is not supported by RHEL6, are deleted from autoconfig scripts.

ifdef::community[]
  %if 0%{?el6}
  %global ruby_sitearch %(ruby -rrbconfig -e 'puts Config::CONFIG["sitearchdir"]')
  %endif

This conditional handles compatibility between Fedora version 17 and newer and RHEL6 in terms of support of the `%ruby_sitearch` macro. Fedora version 17 and newer defines `%ruby_sitearch` by default, but RHEL6 does not support this macro. The conditional checks whether the operating system is RHEL6. If it is, `%ruby_sitearch` is defined explicitly. Note that `0%{?el6}` has the same meaning as `0%{?rhel} == 6` from the previous example, and it tests whether a package is built on RHEL6.
endif::community[]

ifdef::community[]
  %if 0%{?fedora} >= 19
  %global with_rubypick 1
  %endif

This conditional handles support for the rubypick tool. If the operating system is Fedora version 19 or newer, rubypick is supported.
endif::community[]

  %define ruby_archive %{name}-%{ruby_version}
  %if 0%{?milestone:1}%{?revision:1} != 0
  %define ruby_archive %{ruby_archive}-%{?milestone}%{?!milestone:%{?revision:r%{revision}}}
  %endif

This conditional handles definition of the macros. If the `%milestone` or the `%revision` macros are set, the `%ruby_archive` macro, which defines the name of the upstream tarball, is redefined.


==== Specialized variants of `%if` Conditional

The `%ifarch` conditional, `%ifnarch` conditional and `%ifos` conditional are specialized variants of the `%if` conditionals. These variants are commonly used, so they have their own macros.

===== The `%ifarch` Conditional

The `%ifarch` conditional is used to begin a block of the SPEC file that is architecture-specific. It is followed by one or more architecture specifiers, each separated by commas or whitespace.

  %ifarch i386 sparc
  ...
  %endif

All the contents of the spec file  between `%ifarch` and `%endif` are processed only on the 32-bit AMD and Intel architectures or Sun SPARC-based systems.

===== The `%ifnarch` Conditional

The `%ifnarch` conditional has a reverse logic than `%ifarch` conditional.

  %ifnarch alpha
  ...
  %endif

All the contents of the spec file between `%ifnarch` and `%endif` are processed only if not being done on a Digital Alpha/AXP-based system.

===== The `%ifos` Conditional

The `%ifos` conditional is used to control processing based on the operating system of the build. It can be followed by one or more operating system names.

  %ifos linux
  ...
  %endif

All the contents of the spec file between `%ifos` and `%endif` are processed only if the build was done on a Linux system.

[id="Packaging-of-Python-RPMs"]
=== Packaging of Python RPMs

[id="Benefits-of-packaging-Python-packages-as-RPMs"]
==== Benefits of packaging Python packages as RPMs

In comparison with the Python Package Index (PyPI), RPM allows to specify dependencies of other RPMs that are not necessary Python packages. RPM allows to use cryptographic signing, content of RPM packages is verified, integrated, and tested with the rest of the operating system. More can be found in the chapter xref:Why-Package-Software-with-RPM[].

ifdef::community[]

[id="Converting-PyPI-package-to-an-RPM"]
==== Converting PyPI package to an RPM

Pyp2rpm is a tool which automatically converts PyPI packages to an RPM spec file. Simple tutorial can be found on this page link:https://github.com/fedora-python/pyp2rpm[pyp2rpm]. Pyp2rpm is still in development. Some manual corrections might be necessary.

endif::community[]

[id="Typical-Python-RPM-package-spec-file-description"]
==== Typical Python RPM package spec file description

There is a chapter xref:what-is-a-spec-file[], which describes spec file in general. However Python RPM spec file has some specifications. A package setuptools is used as an illustrative example:

ifdef::rhel[]

[source,specfile]
----
Name:           python-setuptools <1>
Version:        0.9.8
Release:        1%{?dist}
Summary:        Easily build and distribute Python packages
License:        Python or ZPLv2.0
URL:            https://pypi.org/project/setuptools/
Source0:        https://files.pythonhosted.org/packages/source/s/setuptools/setuptools-%{version}.zip

BuildArch:      noarch

BuildRequires:  python2-devel <2>

BuildRequires:  python-backports-ssl_match_hostname <3>
Requires:       python-backports-ssl_match_hostname

%description
Setuptools is a collection of enhancements to the Python distutils that allow
you to more easily build and distribute Python packages, especially ones that
have dependencies on other packages.

This package contains the runtime components of setuptools, necessary to
execute the software that requires pkg_resources.py.

%prep
%setup -q -n setuptools-%{version}

%build
CFLAGS="$RPM_OPT_FLAGS" %{__python} setup.py build <4>

%install
%{__python} setup.py install --skip-build --root %{buildroot} <5>

%check
LANG=en_US.utf8 %{__python} setup.py test <6>

%files
%doc *.txt docs
%{python_sitelib}/*
%{_bindir}/easy_install

%changelog
...
----

<1> The name of this package in PyPI is setuptools, in RPM this package has specification "python" in its name.
<2> BuildRequires specifies what packages are required to to build this package.
<3> BuildRequires specifies which Python module package python-setuptools requires.
<4> Without this expression the package might not be possible to build if the package has a C extension. `%{__python} setup.py build` Is similar to make build. Allows to build Python packages.
<5> The setup.py install is similar to make install. On this line, setup.py install would suffice because it builds and installs the package, but for keeping an RPM standard the package is build with setup.py build and installed with the --skip-build option.
<6> Tests vary depending on a particular project. However in RHEL locale has to be specified on LANG=en_US.utf8.

endif::rhel[]

ifdef::community[]

// Next: Use spec file to desribe typical python RPM package in Fedora. https://src.fedoraproject.org/rpms/python-setuptools/blob/master/f/python-setuptools.spec

endif::community[]

[id="Common-macros-for-Python-RPM-packages"]
==== Common macros for Python RPM packages

ifdef::community[]

All Python specific RPM macros can be found on this page link:https://fedoraproject.org/wiki/Packaging:Python#Macros[Python packaging macros].

endif::community[]

ifdef::rhel[]

|===
|Macro |Normal Definition |Notes

|__python
|/usr/bin/python
|Python 2 interpreter

|python_sitelib
|/usr/lib/python.X.Y/site-packages
|Where Python modules written only in Python are installed

|python_version
|2.X
|Defined in python-devel. Useful when running programs with Python version in filename

|python_sitearch
|/usr/lib64/python2.X/site-packages on a 64-bit system
|Where python2 extension modules that are compiled with C are installed
|===

endif::rhel[]

[id="Differences-in-RPM-packages-for-Python-as-a-Software-Collection"]
==== Differences in RPM packages for Python as a Software Collection

ifdef::rhel[]

Those differences are documented in link:https://access.redhat.com/documentation/en-us/red_hat_software_collections/3/html/packaging_guide/sect-enabling_the_software_collection[Red Hat Software Collections]

endif::rhel[]

ifdef::community[]

Those differences are documented in link:https://www.softwarecollections.org/en/docs/guide/#sect-Enabling_the_Software_Collection[Software Collections].

endif::community[]
